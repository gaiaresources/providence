<?php
/** ---------------------------------------------------------------------
 * includes/plugins/IDNumbering/MultipartIDNumber.php : plugin to generate id numbers
 * ----------------------------------------------------------------------
 * CollectiveAccess
 * Open-source collections management software
 * ----------------------------------------------------------------------
 *
 * Software by Whirl-i-Gig (http://www.whirl-i-gig.com)
 * Copyright 2007-2023 Whirl-i-Gig
 *
 * For more information visit http://www.CollectiveAccess.org
 *
 * This program is free software; you may redistribute it and/or modify it under
 * the terms of the provided license as published by Whirl-i-Gig
 *
 * CollectiveAccess is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTIES whatsoever, including any implied warranty of 
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
 *
 * This source code is free and modifiable under the terms of 
 * GNU General Public License. (http://www.gnu.org/copyleft/gpl.html). See
 * the "license.txt" file for details, or visit the CollectiveAccess web site at
 * http://www.CollectiveAccess.org
 *
 * @package CollectiveAccess
 * @subpackage IDNumbering
 * @license http://www.gnu.org/copyleft/gpl.html GNU Public License version 3
 *
 * ----------------------------------------------------------------------
 */
 
require_once(__CA_LIB_DIR__."/IDNumbering/IDNumber.php");
require_once(__CA_APP_DIR__."/helpers/navigationHelpers.php");

class MultipartIDNumber extends IDNumber {
	# -------------------------------------------------------
	/**
	 * Initialize the plugin
	 *
	 * @param string $format A format to set as current [Default is null]
	 * @param mixed $type A type to set a current [Default is __default__] 
	 * @param string $value A value to set as current [Default is null]
	 * @param Db $db A database connection to use for all queries. If omitted a new connection (may be pooled) is allocated. [Default is null]
	 */
	public function __construct($format=null, $type=null, $value=null, $db=null) {
		parent::__construct($format, $type, $value, $db);
	}
	# -------------------------------------------------------
	/**
	 * Return separator string for current format
	 *
	 * @return string Separator, or "." if no separator setting is present
	 */
	public function getSeparator() {
		return $this->getFormatProperty('separator', ['default' => '.']);
	}
	# -------------------------------------------------------
	/**
	 * Determine if the specified format and type contain a SERIAL element its last element; that is, that the format and type 
	 * is designed as an auto incrementing sequence with 0 or more prefix elements.
	 *
	 * @param string $format A format to test. If omitted the current format is used. [Default is null]
	 * @param string $type A type to test. If omitted the current type is used. [Default is null]
	 * @return bool
	 */
	public function isSerialFormat($format=null, $type=null) {
		if(!$format) { $format = $this->getFormat(); }
		if(!$type) { $type = $this->getType(); }
		$format = mb_strtolower($format);
		$type = mb_strtolower($type);
		
		if (!$this->isValidType($type, $format)) { $type = '__default__'; }
		return $this->formatHas('SERIAL', null, $format, $type, ['checkLastElementOnly' => true]);
	}
	# -------------------------------------------------------
	/**
	 * Returns true if the current format is an extension of $format
	 * That is, the current format is the same as the $form with an auto-generated
	 * extra element such that the system can auto-generate unique numbers using a $format
	 * compatible number as the basis. This is mainly used to determine if the system configuration
	 * is such that object numbers can be auto-generated based upon lot numbers.
	 *
	 * @param string $format
	 * @param string $type [Default is __default__]
	 * @return bool
	 */
	public function formatIsExtensionOf($format, $type='__default__') {
		$format = mb_strtolower($format);
		$type = mb_strtolower($type);
		
		if (!$this->isSerialFormat()) {
			return false;	// If this format doesn't end in a SERIAL element it can't be autogenerated.
		}
		if (!$this->isValidFormat($format)) {
			return false;	// specifed format does not exist
		}
		if (!$this->isValidType($type)) {
			return false;	// specifed type does not exist
		}

		$base_elements = $this->formats[$format][$type]['elements'];
		$ext_elements = $this->getElements();

		if (sizeof($ext_elements) != (sizeof($base_elements) + 1)) {
			return false;	// extension should have exactly one more element than base
		}

		$num_elements = sizeof($base_elements);
		for($i=0; $i < $num_elements; $i++) {
			$base_element = array_shift($base_elements);
			$ext_element = array_shift($ext_elements);

			if ($base_element['type'] != $ext_element['type']) { return false; }
			if ($base_element['width'] > $ext_element['width']) { return false; }

			switch($base_element['type']) {
				case 'LIST':
					if (!is_array($base_element['values']) || !is_array($ext_element['values'])) { return false; }
					if (sizeof($base_element['values']) != sizeof($ext_element['values'])) { return false; }
					for($j=0; $j < sizeof($base_element['values']); $j++) {
						if ($base_element['values'][$j] != $ext_element['values'][$j]) { return false; }
					}
					break;
				case 'CONSTANT';
					if ($base_element['value'] != $ext_element['value']) { return false; }
					break;
				case 'NUMERIC':
					if ($base_element['minimum_length'] < $ext_element['minimum_length']) { return false; }
					if ($base_element['maximum_length'] > $ext_element['maximum_length']) { return false; }
					if ($base_element['minimum_value'] < $ext_element['minimum_value']) { return false; }
					if ($base_element['maximum_value'] > $ext_element['maximum_value']) { return false; }
					break;
				case 'ALPHANUMERIC':
					if ($base_element['minimum_length'] < $ext_element['minimum_length']) { return false; }
					if ($base_element['maximum_length'] > $ext_element['maximum_length']) { return false; }
					break;
				case 'FREE':
					if ($base_element['minimum_length'] < $ext_element['minimum_length']) { return false; }
					if ($base_element['maximum_length'] > $ext_element['maximum_length']) { return false; }
					break;
			}
		}

		return true;
	}
	# -------------------------------------------------------
	/**
	 * Breaks apart value using configuration of current format and type. When a format type specifies a separator this is generally
	 * equivalent to explode()'ing the value on the separator, except when PARENT elements (which may contain the separator) are configured.
	 * explodeValue() can also split values when no separator is configured, using configured element widths to determine boundaries.
	 *
	 * @param string $value
	 * @return array List of values
	 */
	protected function explodeValue($value) {
		$separator = $this->getSeparator();
		
		if ($separator && $this->formatHas('PARENT', 0)) {
			// starts with PARENT element so explode in reverse since parent value may include separators

			$element_vals_in_reverse = array_reverse(explode($separator, $value));
			$num_elements = sizeof($elements = $this->getElements());

			$element_vals = [];
			while(sizeof($elements) > 1) {
				array_shift($elements);
				$element_vals[] = array_shift($element_vals_in_reverse);

				$num_elements--;
			}
			$element_vals[] = join($separator, array_reverse($element_vals_in_reverse));
			$element_vals = array_reverse($element_vals);
		} elseif ($separator) {
			// Standard operation, use specified non-empty separator to split value
			$element_vals = explode($separator, $value);
		} else {
			// Separator is explicitly set to empty string, so use element widths to split value
			$element_vals = [];
			$strpos = 0;
			foreach ($this->getElements() as $element_info) {
				switch ($element_info['type']) {
					case 'LIST':
						// The element has an implicit width depending on the selected value in a list
						$matching_value = null;
						foreach ($element_info['values'] as $v) {
							if (substr($value, $strpos, mb_strlen($v)) === $v && (is_null($matching_value) || mb_strlen($matching_value) < mb_strlen($v))) {
								// We have a match, and it is either the first match or the longest match so far
								$matching_value = $v;
							}
						}
						$width = !is_null($matching_value) ? mb_strlen($matching_value) : null;
						break;
					case 'CONSTANT':
						// The element has an implicit width because it is a constant, so read the width of the constant
						$width = mb_strlen($element_info['value']);
						// find the constant in the value - for the case when a constant comes after a PARENT with no separator char
						$strpos = strpos($value, $element_info['value']);
						if (sizeof($element_vals) > 0) {
							// if the previous value in the exploded array is equal to the string, it hasn't been parsed and should be = the substring from 0 - the constant
							$last_element = array_values(array_slice($element_vals, -1))[0];
							if (strcmp($last_element, $value) == 0 || strcmp($last_element, '') == 0) {
								// remove the previous element and add the new substring
								array_pop($element_vals);
								$element_vals[] = substr($value, 0, $strpos);
							}
						}
						break;
					case 'SERIAL':
					case 'YEAR':
					case 'MONTH':
					case 'DAY':
					case 'NUMERIC':
						// Match a sequence of numeric digits
						$width = mb_strlen(preg_replace('/^(\d+).*$/', '$1', substr($value, $strpos)));
						break;
					case 'ALPHANUMERIC':
						// Match a sequence of alphanumeric characters
						$width = mb_strlen(preg_replace('/^([A-Za-z0-9]+).*$/', '$1', substr($value, $strpos)));
						break;
					case 'FREE':
					case 'PARENT':
					default:
						// Match free text
						$width = null;
				}
				if (isset($element_info['width'])) {
					// Use the configured width as either a fallback or a maximum
					$width = is_null($width) ? intval($element_info['width']) : min($width, intval($element_info['width']));
				}
				// Take the calculated width from the input value as the element value; if $width is null, use the remainder
				// of the input string
				$element_vals[] = substr($value, $strpos, $width);
				$strpos = is_null($width) ? mb_strlen($value) : $strpos + $width;
			}
		}
		return $element_vals;
	}
	# -------------------------------------------------------
	/**
	 * Validate value against current format and return list of error messages. 
	 *
	 * @param string $value A value to validate.
	 * @return array List of validation errors for value when applied to current format. Empty array if no error.
	 */
	public function validateValue($value) {
		//if (!$value) { return []; }
		$elements = $this->getElements();
		if (!is_array($elements)) { return []; }

		$element_vals = $this->explodeValue($value);
		$i = 0;
		$element_errors = [];
		foreach($elements as $ename => $info) {
			$v = $element_vals[$i];
			$value_len = mb_strlen($v);

			switch($info['type']) {
				case 'LIST':
					if (!in_array($v, $info['values'])) {
						$element_errors[$ename] = _t("'%1' is not valid for %2", $v, $info['description']);
					}
					break;
				case 'SERIAL':
					if ($v) {
						if (!preg_match("/^[A-Za-z0-9]+$/", $v)) {
							$element_errors[$ename] = _t("'%1' is not valid for %2; only letters and numbers are allowed", $v, $info['description']);
						}
					}
					break;
				case 'CONSTANT':
					if ($v && ($v != $info['value'])) {
						$element_errors[$ename] = _t("%1 must be set to %2; was %3", $info['description'], $info['value'], $v);
					}
					break;
				case 'FREE':
					if (isset($info['minimum_length']) && ($value_len < $info['minimum_length'])) {
						if($info['minimum_length'] == 1) {
							$element_errors[$ename] = _t("%1 must not be shorter than %2 character", $info['description'], $info['minimum_length']);
						} else {
							$element_errors[$ename] = _t("%1 must not be shorter than %2 characters", $info['description'], $info['minimum_length']);
						}
					}
					if (isset($info['maximum_length']) && ($value_len > $info['maximum_length'])) {
						if($info['minimum_length'] == 1) {
							$element_errors[$ename] = _t("%1 must not be longer than %2 character", $info['description'], $info['maximum_length']);
						} else {
							$element_errors[$ename] = _t("%1 must not be longer than %2 characters", $info['description'], $info['maximum_length']);
						}
					}
					break;
				case 'NUMERIC':
					if (!preg_match("/^[\d]+[a-zA-Z]{0,1}$/", $v)) {
						$element_errors[$ename] = _t("%1 must be a number", $info['description']);
					}
					if (isset($info['minimum_value']) && ($v < $info['minimum_value'])) {
						$element_errors[$ename] = _t("%1 must not be less than %2", $info['description'], $info['minimum_value']);
					}
					if (isset($info['maximum_value']) && ($v > $info['maximum_value'])) {
						$element_errors[$ename] = _t("%1 must not be more than %2", $info['description'], $info['maximum_value']);
					}
					if (isset($info['minimum_length']) && ($value_len < $info['minimum_length'])) {
						if ($info['minimum_length'] == 1) {
							$element_errors[$ename] = _t("%1 must not be shorter than %2 character", $info['description'], $info['minimum_length']);
						} else {
							$element_errors[$ename] = _t("%1 must not be shorter than %2 characters", $info['description'], $info['minimum_length']);
						}
					}
					if (isset($info['maximum_length']) && ($value_len > $info['maximum_length'])) {
						if ($info['maximum_length'] == 1) {
							$element_errors[$ename] = _t("%1 must not be longer than %2 character", $info['description'], $info['maximum_length']);
						} else {
							$element_errors[$ename] = _t("%1 must not be longer than %2 characters", $info['description'], $info['maximum_length']);
						}
					}
					break;
				case 'ALPHANUMERIC':
					if ($v != '' && !preg_match("/^[A-Za-z0-9]+$/", $v)) {
						$element_errors[$ename] = _t("%1 must consist only letters and numbers", $info['description']);
					}
					if (isset($info['minimum_length']) && ($value_len < $info['minimum_length'])) {
						if ($info['minimum_length'] == 1) {
							$element_errors[$ename] = _t("%1 must not be shorter than %2 character", $info['description'], $info['minimum_length']);
						} else {
							$element_errors[$ename] = _t("%1 must not be shorter than %2 characters", $info['description'], $info['minimum_length']);
						}
					}
					if (isset($info['maximum_length']) && ($value_len > $info['maximum_length'])) {
						if ($info['maximum_length'] == 1) {
							$element_errors[$ename] = _t("%1 must not be longer than %2 character", $info['description'], $info['maximum_length']);
						} else {
							$element_errors[$ename] = _t("%1 must not be longer than %2 characters", $info['description'], $info['maximum_length']);
						}
					}
					break;
				case 'YEAR':
					$tmp = getdate();
					if ($v != '') {
						if ($info['width'] == 2) {
							if(($v < 0) || ($v > 99)){
								$element_errors[$ename] = _t("%1 must be a valid two-digit year", $info['description']);
							}
						} elseif ((($v < 1000) || ($v > ($tmp['year'] + 10))) || ($v != intval($v))) {
							$element_errors[$ename] = _t("%1 must be a valid year", $info['description']);
						}
					}
					break;
				case 'MONTH':
					if ($v != '') {
						if ((($v < 1) || ($v > 12)) || ($v != intval($v))) {
							$element_errors[$ename] = _t("%1 must be a valid numeric month (between 1 and 12)", $info['description']);
						}
					}
					break;
				case 'DAY':
					if ($v != '') {
						if ((($v < 1) || ($v > 31)) || ($v != intval($v))) {
							$element_errors[$ename] = _t("%1 must be a valid numeric day (between 1 and 31)", $info['description']);
						}
					}
					break;
				default:
					# noop
					break;

			}
			$i++;
		}
		return $element_errors;
	}
	# -------------------------------------------------------
	/**
	 * Check that value is valid for the current format
	 *
	 * @param string $value [Default is null - use current value]
	 * @return bool
	 */
	public function isValidValue($value=null) {
		return $this->validateValue(!is_null($value) ? $value : $this->getValue());
	}
	# -------------------------------------------------------
	/**
	 * Get next integer value in sequence for the specified SERIAL element
	 *
	 * @param string $element_name
	 * @param mixed $value [Default is null]
	 * @param bool  $dont_mark_value_as_used [Default is false]
	 * @return int Next value for SERIAL element or the string "ERR" on error
	 */
	public function getNextValue($element_name, $value=null, $dont_mark_value_as_used=false) {
		if (!$value) { $value = $this->getValue(); }
		$element_info = $this->getElementInfo($element_name);

		$table = $element_info['table'];
		$field = $element_info['field'];
		$sort_field = $element_info['sort_field'];

		if (!$table) { return 'ERR';}
		if (!$field) { return 'ERR';}
		if (!$sort_field) { $sort_field = $field; }

		$separator = $this->getSeparator();
		$elements = $this->getElements();

		if ($value == null) {
			$element_vals = [];
			foreach($elements as $element_name => $element_info) {
				switch($element_info['type']) {
					case 'CONSTANT':
						$element_vals[] = $element_info['value'];
						break;
					case 'YEAR':
					case 'MONTH':
					case 'DAY':
						$date = getDate();
						if ($element_info['type'] == 'YEAR') {
							if ($element_info['width'] == 2) {
								$date['year'] = substr($date['year'], 2, 2);
							}
							$element_vals[] = $date['year'];
						}
						if ($element_info['type'] == 'MONTH') { $element_vals[]  = $date['mon']; }
						if ($element_info['type'] == 'DAY') { $element_vals[]  = $date['mday']; }
						break;
					case 'LIST':
						if ($element_info['default']) {
							$element_vals[] = $element_info['default'];
						} else {
							if (is_array($element_info['values'])) {
								$element_vals[] = array_shift($element_info['values']);
							}
						}
						break;
					case 'PARENT':
						$element_vals[] = $this->getParentValue();
						break;
					default:
						$element_vals[] = '';
						break;
				}
			}
		} elseif(is_array($value)) {
			$element_vals = array_values($value);
		} else {
			$element_vals = $this->explodeValue($value);
		}

		$tmp = [];
		$i = 0;
		foreach($elements as $element_name => $element_info) {
			if ($element_name == $element_name) { break; }
			$tmp[] = array_shift($element_vals);
			$i++;
		}

		$stub = trim(join($separator, $tmp));

		$this->db->dieOnError(false);

		// Get the next number based upon field data
		$type_id = null;
		$type_limit_sql = '';
		
		if (!($t_instance = Datamodel::getInstanceByTableName($table, true))) { return 'ERR'; }
		if ((bool)$element_info['sequence_by_type']) {
			$type = $this->getType();
			if ($type == '__default__') {
			    $types = $this->getTypes(); 
			    
			    $exclude_type_ids = [];
			    foreach($types as $type) {
			        if ($type == '__default__') { continue; }
			        if ($type_id = (int)$t_instance->getTypeIDForCode($type)) {
			            $exclude_type_ids[] = $type_id;
			        }
			    }
			    if (sizeof($exclude_type_ids) > 0) {
			        $type_limit_sql = " AND type_id NOT IN (".join(", ", $exclude_type_ids).")";
			    }
			} elseif($type_id = (int)$t_instance->getTypeIDForCode($type)) {
		        $type_limit_sql = " AND type_id = {$type_id}";
		    }
		}
		
		$stub_prefix = ($stub == '' ? '' : $stub . $separator);
		$field_like = $stub_prefix . '%';
		$field_match_sql = " $field LIKE '{$field_like}' ";
		if ($separator) {
			$field_not_like = $stub_prefix . '%' . $separator . '%';
			$field_match_sql .= " AND $field NOT LIKE '{$field_not_like}' ";
		}
		
		if ($qr_res = $this->db->query("
			SELECT {$field} FROM {$table}
			WHERE
				{$field_match_sql}
				{$type_limit_sql}
				".($t_instance->hasField('deleted') ? " AND (deleted = 0)" : '')."
			ORDER BY
				$sort_field DESC"
		)) {
			if ($this->db->numErrors()) {
				return "ERR";
			}
			
			// Figure out what the sequence (last) number in the multipart number taken from the field is...
			if ($qr_res->numRows()) {
				while($qr_res->nextRow()) {
					$tmp = $this->explodeValue($qr_res->get($field));
					if(is_numeric($tmp[$i])) {
						$num = intval($tmp[$i]) + 1;
						break;
					}
				}
				if ($num == '') { $num = 1; }
				if (is_array($tmp)) {
					array_pop($tmp);
					$stub = join($separator, $tmp);
				} else {
					$stub = '';
				}
			} else {
				$num = 1;
			}

			// Now get the last used sequence number for this "stub"
			$max_num = $this->getSequenceMaxValue($this->getFormat(), $element_name, $stub);

			// Make the new number one more than the last used number if it is less than the last
			// (this prevents numbers from being reused when records are deleted or renumbered)
			if ($num <= $max_num) {
				$num = $max_num + 1;
			}
			
			// Record this newly issued number as the new "last used" number, unless told not to do so
			if (!$dont_mark_value_as_used) {
				$this->setSequenceMaxValue($this->getFormat(), $element_name, $stub, $num);
			}
			
			if (($zeropad_to_length = (int)$element_info['zeropad_to_length']) > 0) {
				return sprintf("%0{$zeropad_to_length}d", $num);
			} else {
				return $num;
			}
		} else {
			return 'ERR'; 
		}
	}
	# -------------------------------------------------------
	/**
	 * Returns sortable value padding according to the format of the specified format and type
	 *
	 * @param string $value Value from which to derive the sortable value. If omitted the current value is used. [Default is null]
	 * @return string The sortable value
	 */
	public function getSortableValue($value=null) {
		$separator = $this->getSeparator();
		if (!is_array($elements_normal_order = $this->getElements())) { $elements_normal_order = []; }
		$element_names_normal_order = array_keys($elements_normal_order);

		if (!($elements = $this->getElementOrderForSort())) { $elements = $element_names_normal_order; }
		$element_values = $this->explodeValue($value ?: $this->getValue());
		$output = [];

		foreach ($elements as $element) {
			$element_info = $elements_normal_order[$element];
			$i = array_search($element, $element_names_normal_order);
			$padding = 20;
			
			$v = $element_values[$i];

			switch($element_info['type']) {
				case 'LIST':
					$w = $padding - mb_strlen($v);
					if ($w < 0) { $w = 0; }
					$output[] = str_repeat(' ', $w).$v;
					break;
				case 'CONSTANT':
					$len = mb_strlen($element_info['value']);
					if ($padding < $len) { $padding = $len; }
					$repeat_len = ($padding - mb_strlen($v));
					$n = $padding - mb_strlen($v);
					$output[] = (($repeat_len > 0) ? str_repeat(' ', $n) : '').$v;
					break;
				case 'FREE':
				case 'ALPHANUMERIC':
					$tmp = preg_split('![^A-Za-z0-9]+!',  $v);

					$zeroless_output = [];
					$raw_output = [];
					while(sizeof($tmp)) {
						$piece = array_shift($tmp);
						if (preg_match('!^([\d]+)(.*)!', $piece, $matches)) {
							$piece = $matches[1];

							if (sizeof($matches) >= 3) {
								array_unshift($tmp, $matches[2]);
							}
						}
						$pad_len = $padding - mb_strlen($piece);

						if ($pad_len >= 0) {
							if (is_numeric($piece)) {
								$raw_output[] = str_repeat(' ', $pad_len).$matches[1];
							} else {
								$raw_output[] = $piece.str_repeat(' ', $pad_len);
							}
						} else {
							$raw_output[] = $piece;
						}
						if ($tmp = preg_replace('!^[0]+!', '', $piece)) {
							$zeroless_output[] = $tmp;
						} else {
							$zeroless_output[] = $piece;
						}
					}
					$output[] = join('', $raw_output); 
					break;
				case 'SERIAL':
				case 'NUMERIC':
					if ($padding < $element_info['width']) { $padding = $element_info['width']; }
					$output[] = str_repeat(' ', $padding - strlen(intval($v))).intval($v);
					break;
				case 'YEAR':
					$p = (($element_info['width'] == 2) ? 2 : 4) - mb_strlen($v);
					if ($p < 0) { $p = 0; }
					$output[] = str_repeat(' ', $p).$v;
					break;
				case 'MONTH':
				case 'DAY':
					$p = 2 - mb_strlen($v);
					if ($p < 0) { $p = 0; }
					$n = 2 - $p;
					$output[] = str_repeat(' ', $n).$v;
					break;
				case 'PARENT':
					$output[] = $v.str_repeat(' ', $padding - mb_strlen($v));
					break;
				default:
					$n = $padding - mb_strlen($v);
					$output[] = str_repeat(' ', $n).$v;
					break;

			}
		}
		return join($separator, $output);
	}
	# -------------------------------------------------------
	/**
	 * Return a list of modified identifier values suitable for search indexing according to the format of the specified format and type
	 * Modifications include removal of leading zeros, stemming and more.
	 *
	 * @param string $value Value from which to derive the index values. If omitted the current value is used. [Default is null]
	 * @return array Array of strings for indexing
	 */
	public function getIndexValues($value=null, $options=null) {
		$separator = $this->getSeparator();
		if (!is_array($elements_normal_order = $this->getElements())) { $elements_normal_order = []; }
		$element_names_normal_order = array_keys($elements_normal_order);

		if (!($elements = $this->getElementOrderForSort())) { $elements = $element_names_normal_order; }
		$element_values = $this->explodeValue($value ?: $this->getValue());
		
		$output = [join($separator, $element_values)];
		$i = $max_value_count = 0;

		// element-specific processing
		foreach($elements as $element) {
			$element_info = $elements_normal_order[$element];
			$i = array_search($element, $element_names_normal_order);

			switch($element_info['type']) {
				case 'LIST':
					$output[$i] = array($element_values[$i]);
					break;
				case 'CONSTANT':
					$output[$i] = array($element_values[$i]);
					break;
				case 'FREE':
				case 'ALPHANUMERIC':
					$output[$i] = array($element_values[$i]);
					if ((int)$element_values[$i] > 0) {
						$output[$i][] = (int)$element_values[$i];
					}
					break;
				case 'SERIAL':
				case 'NUMERIC':
				case 'MONTH':
				case 'DAY':
				case 'YEAR':
					$output[$i] = array($element_values[$i]);
					if (preg_match('!^([0]+)([\d]+)$!', $element_values[$i], $matches)) {
					    for($i=0; $i < sizeof($matches[1]); $i++) {
							$output[$i][] = substr($element_values[$i], $i);
						}
					}
					break;
				default:
					$output[$i] = array($element_values[$i]);
					break;
			}

			if ($max_value_count < sizeof($output[$i])) { $max_value_count = sizeof($output[$i]); }
		}

		$output_values = [];

		// Generate permutations from element-specific processing
		for($c=0; $c < $max_value_count; $c++) {
			$output_values_buf = [];

			foreach($elements as $element) {
				if (!isset($output[$i][0])) { continue; }

				$i = array_search($element, $element_names_normal_order);
				if (isset($output[$i][$c])) {
					$output_values_buf[] = $output[$i][$c];
				} else {
					$output_values_buf[] = $output[$i][0];
				}
			}

			$output_values[] = join($separator, $output_values_buf);
		}

		// generate incremental "stems" of identifier by exploding on punctuation
		if(preg_match_all("![^A-Za-z0-9]+!", $value, $delimiters)) {
			$element_values = preg_split("![^A-Za-z0-9]+!", $value);
			$acc = [];
			foreach($element_values as $element_value) {
				$acc[] = $element_value;
				$output_values[] = join('', $acc);
				if (is_numeric($element_value)) {
					array_pop($acc);
					$acc[] = $element_value;
					$output_values[] = join('', $acc);
				}
				if (sizeof($delimiters[0]) > 0) { $acc[] = array_shift($delimiters[0]); }
			}
		}

		// generate versions without leading zeros
		$output_values[] = preg_replace("!^[0]+!", "", $value);	// remove leading zeros
		if (preg_match_all("!([^0-9]+)([0]+)!", $value, $matches)) {
			$value_proc = $value;
			for($x=0; $x < sizeof($matches[0]); $x++) {
				$value_proc = str_replace($matches[0][$x], $matches[1][$x], $value_proc);
			}
			$output_values[] = $value_proc;
		}

		// generate version without trailing letters after number (eg. KHF-134b => KHF-134)
		$tmp = $output_values;
		foreach($tmp as $value_proc) {
			$output_values[] = preg_replace("!([\d]+)[A-Za-z]+$!", "$1", $value_proc);
		}
		
		$output_values = array_unique($output_values);
		
		// generate tokenized version
		if($tokens = preg_split("![".$this->search_config->get('indexing_tokenizer_regex')."]+!", $value)) {
			$output_values = array_merge($output_values, $tokens);
		}
		
		if (isset($options['INDEX_IDNO_PARTS']) || (is_array($options) && (in_array('INDEX_IDNO_PARTS', $options)))) {
		    if (is_array($delimiters = caGetOption('IDNO_DELIMITERS', $options, [$this->getSeparator()])) && sizeof($delimiters)) {
		        $output_values = array_merge($output_values, preg_split("![".preg_quote(join('', $delimiters), "!")."]!", $value));
		    }
		}
		return array_unique($output_values);
	}
	# -------------------------------------------------------
	# User interace (HTML)
	# -------------------------------------------------------
	/**
	 * Return HTML form elements for all elements using the current format, type and value
	 *
	 * @param string $name Name of form element. Is used as a prefix for each form element. The number element name will be used as a suffix for each.
	 * @param array $errors Passed-by-reference array. Will contain any validation errors for the value, indexed by element.
	 * @param array $options Options include:
	 *		id_prefix = Prefix to add to element ID attributes. [Default is null]
	 *		for_search_form = Generate a blank form for search. [Default is false]
	 *		show_errors = Include error messages next to form elements. [Default is false]
	 *		error_icon = Icon to display next to error messages; should be ready-to-display HTML. [Default is null]
	 *		readonly = Make all form elements read-only. [Default is false]
	 *		request = the current request (an instance of RequestHTTP) [Default is null]
	 *		check_for_dupes = perform live checking for duplicate numbers. [Default is false]
	 *		progress_indicator = URL for spinner graphic to use while running duplicate number check. [Default is null] 
	 *		table = Table to perform duplicate number check in. [Default is null]
	 *		search_url = Search service URL to use when performing duplicate number check. [Default is null]
	 *		row_id = ID of row to exclude from duplicate number check (typically the current record id). [Default is null]
	 *		context_id = context ID of row to exclude from duplicate number check (typically the current record context). [Default is null]
	 * @return string HTML output
	 */
	public function htmlFormElement($name, &$errors=null, $options=null) {
		if (!is_array($options)) { $options = []; }
		$id_prefix = isset($options['id_prefix']) ? $options['id_prefix'] : null;
		$generate_for_search_form = isset($options['for_search_form']) ? true : false;

		$errors = $this->validateValue($this->getValue());
		$separator = $this->getSeparator();
		$element_values = $this->explodeValue($this->getValue());
		
		$dont_allow_editing = isset($options['row_id']) && ($options['row_id'] > 0) && $this->config->exists($this->getFormat().'_dont_allow_editing_of_codes_when_in_use') && (bool)$this->config->get($this->getFormat().'_dont_allow_editing_of_codes_when_in_use');
		if ($dont_allow_editing) { $options['readonly'] = true; }

		if (!is_array($elements = $this->getElements())) { $elements = []; }

		$element_controls = $element_control_names = [];
		$i=0;

		$next_in_seq_is_present = false;
		foreach($elements as $ename => $info) {
			if (($info['type'] == 'SERIAL') && ($element_values[$i] == '')) {
				$next_in_seq_is_present = true;
			}
			$tmp = $this->genNumberElement($ename, $name, $element_values[$i], $id_prefix, $generate_for_search_form, $options);
			$element_control_names[] = $name.'_'.$ename;

			if (($options['show_errors']) && (isset($errors[$ename]))) {
				$error_message = preg_replace("/[\"\']+/", "", $errors[$ename]);
				if ($options['error_icon']) {
					$tmp .= "<a href='#' id='caIdno_{$id_prefix}_{$name}'>".$options['error_icon']."</a>";
				} else {
					$tmp .= "<a href='#' id='caIdno_{$id_prefix}_{$name}'>["._t('Error')."]</a>";
				}
				TooltipManager::add("#caIdno_{$id_prefix}_{$name}", "<h2>"._t('Error')."</h2>{$error_message}");
			}
			$element_controls[] = $tmp;
			$i++;
		}
		if ((sizeof($elements) < sizeof($element_values)) && (bool)$this->getFormatProperty('allow_extra_elements', array('default' => 1))) {
			$extra_values = array_slice($element_values, sizeof($elements));
			
			if (($extra_size = (int)$this->getFormatProperty('extra_element_width', array('default' => 10))) < 1) {
				$extra_size = 10;
			}
			foreach($extra_values as $i => $v) {
				$element_controls[] = "<input type='text' name='{$name}_extra_{$i}' id='{$name}_extra_{$i}' value='".htmlspecialchars($v, ENT_QUOTES, 'UTF-8')."' size='{$extra_size}'".($options['readonly'] ? ' disabled="1" ' : '').">";
				$element_control_names[] = $name.'_extra_'.$i;
			}
		}
		
		if ($this->config->exists($this->getFormat().'_dont_allow_editing_of_codes_when_in_use')) {
			if (isset($options['row_id']) && ($options['row_id'] > 0)) {
				if ($dont_allow_editing) {
					$element_controls[] =  '<span class="formLabelWarning"><i class="caIcon fa fa-info-circle fa-1x"></i> '._t('Value cannot be edited because it is in use').'</span>';	
				} else {
					$element_controls[] =  '<span class="formLabelWarning"><i class="caIcon fa fa-exclamation-triangle fa-1x"></i> '._t('Changing this value may break parts of the system configuration').'</span>';	
				}
			}
		}

		$js = '';
		if (($options['check_for_dupes']) && !$next_in_seq_is_present){
			$ids = [];
			foreach($element_control_names as $v) {
				$ids[] = "'#".$id_prefix.$v."'";
			}

			$js = '<script type="text/javascript" language="javascript">'."\n// <![CDATA[\n";
			$lookup_url_info = caJSONLookupServiceUrl($options['request'], $options['table']);
			$js .= "
				caUI.initIDNoChecker({
					errorIcon: \"".$options['error_icon']."\",
					processIndicator: \"".$options['progress_indicator']."\",
					idnoStatusID: 'idnoStatus',
					lookupUrl: '".$lookup_url_info['idno']."',
					searchUrl: '".$options['search_url']."',
					idnoFormElementIDs: [".join(',', $ids)."],
					separator: '".$this->getSeparator()."',
					row_id: ".intval($options['row_id']).",
					context_id: ".intval($options['context_id']).",

					singularAlreadyInUseMessage: '".addslashes(_t('Identifier is already in use'))."',
					pluralAlreadyInUseMessage: '".addslashes(_t('Identifier is already in use %1 times'))."'
				});
			";

			$js .= "// ]]>\n</script>\n";
		}

		return join($separator, $element_controls).$js;
	}
	# -------------------------------------------------------
	/**
	 * When displayed in a form for editing a multipart identifier will be composed of as many form elements as there are elements defined for the identifier format.
	 * Each form element will have a name beginning with the identifier field name and suffixed with the name of the identifier element. htmlFormValue() 
	 * will pull these values from either an incoming request or, if specified, from the value specified in the $value parameter and return it as a string.
	 * This method is identical to htmlFormValuesAs[] save that it returns a string rather than an array.
	 *
	 * @param string $name Name of the identifier field (eg. idno)
	 * @param string $value An optional value to extract form values from. If null, values are pulled from the current request. [Default is null]
	 * @param bool $dont_mark_serial_value_as_used Don't record incoming value of the new maximum for SERIAL element sequences. [Default is false]
	 * @param bool $generate_for_search_form Return array of empty values suitable for use in a search (not editing) form. [Default is false]
	 * @param bool $always_generate_serial_values Always generate new values for SERIAL elements, even if they are not set with placeholders. [Default is false]
	 * @return String Identifier from extracted from form and returned as string
	 */
	public function htmlFormValue($name, $value=null, $dont_mark_serial_value_as_used=false, $generate_for_search_form=false, $always_generate_serial_values=false) {
		$tmp = $this->htmlFormValuesAsArray($name, $value, $dont_mark_serial_value_as_used, $generate_for_search_form, $always_generate_serial_values);
		if (!($separator = $this->getSeparator())) { $separator = ''; }

		return (is_array($tmp)) ? join($separator, $tmp) : null;
	}
	# -------------------------------------------------------
	/**
	 * Generates an id numbering template (text with "%" characters where serial values should be inserted)
	 * from a value. The elements in the value that are generated as SERIAL incrementing numbers will be replaced
	 * with "%" characters, resulting is a template suitable for use with BundlableLabelableBaseModelWithAttributes::setIdnoTWithTemplate
	 * If the $pb_no_placeholders parameter is set to true then SERIAL values are omitted altogether from the returned template.
	 *
	 * Note that when the number of element replacements is limited, the elements are counted right-to-left. This means that
	 * if you limit the template to two replacements, the *rightmost* two SERIAL elements will be replaced with placeholders.
	 *
	 * @see BundlableLabelableBaseModelWithAttributes::setIdnoTWithTemplate
	 *
	 * @param string $value The id number to use as the basis of the template
	 * @param int $max_num_replacements The maximum number of elements to replace with placeholders. Set to 0 (or omit) to replace all SERIAL elements.
	 * @param bool $no_placeholders If set SERIAL elements are omitted altogether rather than being replaced with placeholder values
	 *
	 * @return string A template
	 */
	public function makeTemplateFromValue($value, $max_num_replacements=0, $no_placeholders=false) {
		$separator = $this->getSeparator();
		$values = $this->explodeValue($value);
		$elements = $this->getElements();
		$num_serial_elements = 0;
		foreach ($elements as $element_info) {
			if ($element_info['type'] == 'SERIAL') { $num_serial_elements++; }
		}

		$i = 0;
		$num_serial_elements_seen = 0;
		
		foreach ($elements as $element_info) {
			switch($element_info['type']) {
				case 'SERIAL':
					$num_serial_elements_seen++;

					if ($max_num_replacements <= 0) {	// replace all
						if ($no_placeholders) { unset($values[$i]); $i++; continue; }
						$values[$i] = '%';
					} else {
						if (($num_serial_elements - $num_serial_elements_seen) < $max_num_replacements) {
							if ($no_placeholders) { unset($values[$i]); $i++; continue; }
							$values[$i] = '%';
						}
					}
					break;
				case 'CONSTANT':
					$values[$i] = $element_info['value'];
					break;
				case 'YEAR':
					if (caGetOption('force_derived_values_to_current_year', $element_info, false)) {
						$tmp = getdate();
						$values[$i] = $tmp['year'];
					}
					break;
				case 'MONTH':
					if (caGetOption('force_derived_values_to_current_month', $element_info, false)) {
						$tmp = getdate();
						$values[$i] = $tmp['mon'];
					}
					break;
				case 'DAY':
					if (caGetOption('force_derived_values_to_current_day', $element_info, false)) {
						$tmp = getdate();
						$values[$i] = $tmp['mday'];
					}
					break;
			}

			$i++;
		}
		return join($separator, $values);
	}
	# -------------------------------------------------------
	/**
	 * When displayed in a form for editing a multipart identifier will be composed of as many form elements as there are elements defined for the identifier format.
	 * Each form element will have a name beginning with the identifier field name and suffixed with the name of the identifier element. htmlFormValuesAs[] 
	 * will pull these values from either an incoming request or, if specified, from the value specified in the $value parameter and return them as an array
	 * indexed with keys that identifier name + "_" + element name.
	 *
	 * @param string $name Name of the identifier field (eg. idno)
	 * @param string $value An optional value to extract form values from. If null, values are pulled from the current request. [Default is null]
	 * @param bool $dont_mark_serial_value_as_used Don't record incoming value of the new maximum for SERIAL element sequences. [Default is false]
	 * @param bool $generate_for_search_form Return array of empty values suitable for use in a search (not editing) form. [Default is false]
	 * @param bool $always_generate_serial_values Always generate new values for SERIAL elements, even if they are not set with placeholders. [Default is false]
	 * @return array Array of values for identifer extracted from request
	 */
	public function htmlFormValuesAsArray($name, $value=null, $dont_mark_serial_value_as_used=false, $generate_for_search_form=false, $always_generate_serial_values=false) {
		if (is_null($value)) {
			if(isset($_REQUEST[$name]) && $_REQUEST[$name]) { return $_REQUEST[$name]; }
		}
		if (!is_array($elements = $this->getElements())) { return null; }

		$element_names = array_keys($elements);
		$separator = $this->getSeparator();
		$element_values = [];
		if ($value) {
			$tmp = $this->explodeValue($value);
			foreach ($element_names as $ename) {
				if (!sizeof($tmp)) { break; }
				$element_values[$name.'_'.$ename] = array_shift($tmp);
			}
			if ((sizeof($tmp) > 0) && (bool)$this->getFormatProperty('allow_extra_elements', array('default' => 1))) {
				$i = 0;
				foreach($tmp as $t) {
					$element_values[$name.'_extra_'.$i] = $t;
					$i++;
				}
			}
		} else {
			foreach ($element_names as $ename) {
				if(isset($_REQUEST[$name.'_'.$ename])) {
					$element_values[$name.'_'.$ename] = $_REQUEST[$name.'_'.$ename];
				}
			}
			
			if ((bool)$this->getFormatProperty('allow_extra_elements', array('default' => 1))) {
				$i = 0;
				while(true) {
					if(isset($_REQUEST[$name.'_extra_'.$i])) {
						$element_values[$name.'_extra_'.$i] = $_REQUEST[$name.'_extra_'.$i];
						$i++;
					} else {
						break;
					}
				}
			}
		}

		$isset = $is_not_empty = false;
		$tmp = [];
		foreach($elements as $ename => $info) {
			if ($info['type'] == 'SERIAL') {
				if ($generate_for_search_form) {
					$tmp[$ename] = $element_values[$name.'_'.$ename];
					continue;
				}

				if (($element_values[$name.'_'.$ename] == '') || ($element_values[$name.'_'.$ename] == '%') || $always_generate_serial_values) {
					if ($element_values[$name.'_'.$ename] == '%') { $element_values[$name.'_'.$ename] = ''; }
					$tmp[$ename] = $this->getNextValue($ename, $tmp, $dont_mark_serial_value_as_used);
					$isset = $is_not_empty = true;
					continue;
				} else {
					if (!$dont_mark_serial_value_as_used && (intval($element_values[$name.'_'.$ename]) > $this->getSequenceMaxValue($name, $ename, ''))) {
						$this->setSequenceMaxValue($this->getFormat(), $ename, join($separator, $tmp), $element_values[$name.'_'.$ename]);
					}
				}
			}

			if ($generate_for_search_form) {
				if ($element_values[$name.'_'.$ename] == '') {
					$tmp[$ename] = '';
					break;
				}
			}
			$tmp[$ename] = $element_values[$name.'_'.$ename];

			if ($zeropad_to_length = caGetOption('zeropad_to_length', $info, null)) {
				$tmp[$ename] = str_pad($tmp[$ename], $zeropad_to_length, "0", STR_PAD_LEFT);
			}

			if (isset($element_values[$name.'_'.$ename])) {
				$isset = true;
			}
			if ($element_values[$name.'_'.$ename] != '') {
				$is_not_empty = true;
			}
		}
		
		if((bool)$this->getFormatProperty('allow_extra_elements', array('default' => 1))) {
			$i = 0;
			while(true) {
				if (isset($element_values[$name.'_extra_'.$i]) && ($t = $element_values[$name.'_extra_'.$i])) {
					$tmp[$name.'_extra_'.$i] = $t;
					$i++;
				} else {
					break;
				}	
			}
		}
		
		return ($isset && $is_not_empty) ? $tmp : null;
	}
	# -------------------------------------------------------
	# Generated id number element
	# -------------------------------------------------------
	/**
	 * Return width of specified element
	 *
	 * @param array $element_info Array of information about the specified element, as returned by getElements()
	 * @param int $default Default width, in characters, to use when width is not set in element info [Default is 3]
	 * @return int Width, in characters
	 */
	private function getElementWidth($element_info, $default=3) {
		$width = isset($element_info['width']) ? $element_info['width'] : 0;
		if ($width <= 0) { $width = $default; }

		return $width;
	}
	# -------------------------------------------------------
	/**
	 * Generate an individual HTML form element for a specific number element. Used by htmlFormElement() to create a set of form element for the current format type.
	 *
	 * @param string $element_name Number element to generate form element for.
	 * @param string $name Name of the identifier field (eg. idno)
	 * @param string $value An optional value to extract form values from. If null, values are pulled from the current request. [Default is null]
	 * @param string $id_prefix Prefix to add to element ID attributes. [Default is null]
	 * @param bool $generate_for_search_form Return array of empty values suitable for use in a search (not editing) form. [Default is false]
	 * @param array $options Options include:
	 *		readonly = Make form element read-only. [Default is false]
	 * @return string HTML output
	 */
	private function genNumberElement($element_name, $name, $value, $id_prefix=null, $generate_for_search_form=false, $options=null) {
		if (!($format = $this->getFormat())) {
			return null;
		}
		if (!($type = $this->getType())) {
			return null;
		}
		$element = '';

		$element_info = $this->formats[$format][$type]['elements'][$element_name];
		$element_form_name = $name.'_'.$element_name;

		$element_value = $value;
		switch($element_info['type']) {
			# ----------------------------------------------------
			case 'LIST':
				if (!is_array($element_info['values'])) { $element_info['values'] = []; }
				if (!$element_value || $element_info['editable'] || $generate_for_search_form) {
					if (!$element_value && !$generate_for_search_form) { $element_value = $element_info['default']; }
					$element = '<select name="'.$element_form_name.'" id="'.$id_prefix.$element_form_name.'">';
					if ($generate_for_search_form) {
						$element .= "<option value='' selected='selected'>-</option>";
					}
					foreach ($element_info['values'] as $value) {
						if (trim($value) === trim($element_value)) { $selected = ' selected="selected"'; } else { $selected = ''; }
						$element .= '<option value="'.$value.'"'.$selected.'>'.$value.'</option>';
					}

					if (!$generate_for_search_form) {
						if (!in_array($element_value, $element_info['values']) && strlen($element_value) > 0) {
							$element .= '<option value="'.$element_value.'" selected="selected">'.$element_value.'</option>';
						}
					}

					$element .= '</select>';
				} else {
					$element_val_proc = (in_array($element_value, $element_info['values']) ? $element_value : $element_info['values'][0]);
					$element .= '<input type="hidden" name="'.$element_form_name.'" id="'.$id_prefix.$element_form_name.'" value="'.htmlspecialchars($element_val_proc, ENT_QUOTES, 'UTF-8').'"/>'.$element_val_proc;
				}

				break;
			# ----------------------------------------------------
			case 'SERIAL':
				$width = $this->getElementWidth($element_info, 3);

				if ($generate_for_search_form) {
					$element .= '<input type="text" name="'.$element_form_name.'" id="'.$id_prefix.$element_form_name.'" value="" maxlength="'.$width.'" size="'.$width.'"'.($options['readonly'] ? ' disabled="1" ' : '').'/>';
				} else {
					if ($element_value == '') {
						$next_num = $this->getNextValue($element_name, null, true);
						$element .= '&lt;'._t('Will be assigned %1 when saved', $next_num).'&gt;';
					} else {
						if ($element_info['editable']) {
							$element .= '<input type="text" name="'.$element_form_name.'" id="'.$id_prefix.$element_form_name.'" value="'.htmlspecialchars($element_value, ENT_QUOTES, 'UTF-8').'" size="'.$width.'" maxlength="'.$width.'"'.($options['readonly'] ? ' disabled="1" ' : '').'/>';
						} else {
							$element .= '<input type="hidden" name="'.$element_form_name.'" id="'.$id_prefix.$element_form_name.'" value="'.htmlspecialchars($element_value, ENT_QUOTES, 'UTF-8').'"/>'.$element_value;
						}
					}
				}
				break;
			# ----------------------------------------------------
			case 'CONSTANT':
				$width = $this->getElementWidth($element_info, 3);

				if (!$element_value) { $element_value = $element_info['value']; }
				if ($element_info['editable'] || $generate_for_search_form) {
					$element .= '<input type="text" name="'.$element_form_name.'" id="'.$id_prefix.$element_form_name.'" value="'.htmlspecialchars($element_value, ENT_QUOTES, 'UTF-8').'" size="'.$width.'"'.($options['readonly'] ? ' disabled="1" ' : '').'/>';
				} else {
					$element .= '<input type="hidden" name="'.$element_form_name.'" id="'.$id_prefix.$element_form_name.'" value="'.htmlspecialchars($element_value, ENT_QUOTES, 'UTF-8').'"/>'.$element_value;
				}
				break;
			# ----------------------------------------------------
			case 'FREE':
			case 'NUMERIC':
			case 'ALPHANUMERIC':
				if (!$element_value && !$generate_for_search_form) { $element_value = $element_info['default']; }
				$width = $this->getElementWidth($element_info, 3);
				if (!$element_value || $element_info['editable'] || $generate_for_search_form) {
					$element .= '<input type="text" name="'.$element_form_name.'" id="'.$id_prefix.$element_form_name.'" value="'.htmlspecialchars($element_value, ENT_QUOTES, 'UTF-8').'" size="'.$width.'" maxlength="'.$width.'"'.($options['readonly'] ? ' disabled="1" ' : '').'/>';
				} else {
					$element .= '<input type="hidden" name="'.$element_form_name.'" id="'.$id_prefix.$element_form_name.'" value="'.htmlspecialchars($element_value, ENT_QUOTES, 'UTF-8').'"/>'.$element_value;
				}
				break;
			# ----------------------------------------------------
			case 'YEAR':
			case 'MONTH':
			case 'DAY':
				$width = $this->getElementWidth($element_info, 5);
				$date = getdate();
				if ($element_value == '') {
					$v = '';
					if (!$generate_for_search_form) {
						if ($element_info['type'] == 'YEAR') { $v = ($element_info['width'] == 2) ? substr($date['year'], 2, 2) : $date['year']; }
						if ($element_info['type'] == 'MONTH') { $v = $date['mon']; }
						if ($element_info['type'] == 'DAY') { $v = $date['mday']; }
					}

					if ($element_info['editable'] || $generate_for_search_form) {
						$element .= '<input type="text" name="'.$element_form_name.'" id="'.$id_prefix.$element_form_name.'" value="'.htmlspecialchars($v, ENT_QUOTES, 'UTF-8').'" size="'.$width.'"'.($options['readonly'] ? ' disabled="1" ' : '').'/>';
					} else {
						$element .= '<input type="hidden" name="'.$element_form_name.'" id="'.$id_prefix.$element_form_name.'" value="'.htmlspecialchars($v, ENT_QUOTES, 'UTF-8').'"/>'.$v;
					}
				} else {
					if ($element_info['editable'] || $generate_for_search_form) {
						$element .= '<input type="text" name="'.$element_form_name.'" id="'.$id_prefix.$element_form_name.'" value="'.htmlspecialchars($element_value, ENT_QUOTES, 'UTF-8').'" size="'.$width.'"'.($options['readonly'] ? ' disabled="1" ' : '').'/>';
					} else {
						$element .= '<input type="hidden" name="'.$element_form_name.'" id="'.$id_prefix.$element_form_name.'" value="'.htmlspecialchars($element_value, ENT_QUOTES, 'UTF-8').'"/>'.$element_value;
					}
				}

				break;
			# ----------------------------------------------------
				case 'PARENT':
				$width = $this->getElementWidth($element_info, 3);

				if ($generate_for_search_form) {
					$element .= '<input type="text" name="'.$element_form_name.'" id="'.$id_prefix.$element_form_name.'" value="" maxlength="'.$width.'" size="'.$width.'"'.($options['readonly'] ? ' disabled="1" ' : '').'/>';
				} else {
					if ($element_value == '') {
						$next_num = $this->getParentValue();
						$element .= '&lt;'._t('%1', $next_num).'&gt;'.'<input type="hidden" name="'.$element_form_name.'" id="'.$id_prefix.$element_form_name.'" value="'.htmlspecialchars($next_num, ENT_QUOTES, 'UTF-8').'"/>';
					} else {
						if ($element_info['editable']) {
							$element .= '<input type="text" name="'.$element_form_name.'" id="'.$id_prefix.$element_form_name.'" value="'.htmlspecialchars($element_value, ENT_QUOTES, 'UTF-8').'" size="'.$width.'" maxlength="'.$width.'"'.($options['readonly'] ? ' disabled="1" ' : '').'/>';
						} else {
							$element .= '<input type="hidden" name="'.$element_form_name.'" id="'.$id_prefix.$element_form_name.'" value="'.htmlspecialchars($element_value, ENT_QUOTES, 'UTF-8').'"/>'.$element_value;
						}
					}
				}
					break;
			# ----------------------------------------------------
			default:
				return '[Invalid element type]';
				break;
			# ----------------------------------------------------
		}
		return $element;
	}
	# -------------------------------------------------------
	/**
	 * Get maximum sequence value for SERIAL element
	 *
	 * @param string $format Format to get maximum sequence value for
	 * @param string $element Element name to get maximum sequence value for
	 * @param string $idno_stub Identifier stub (identifier without serial value) to get maximum sequence value for
	 * @return int Integer value or false on error
	 */
	public function getSequenceMaxValue($format, $element, $idno_stub) {
		$this->db->dieOnError(false);

		$minimum_value = caGetOption('minimum_value', $this->getElementInfo($element), 0, ['castTo' => 'int']);
		if (!($qr_res = $this->db->query("
			SELECT seq
			FROM ca_multipart_idno_sequences
			WHERE
				(format = ?) AND (element = ?) AND (idno_stub = ?)
		", $format, $element, $idno_stub))) {
			return false;
		}
		if (!$qr_res->nextRow()) { return $minimum_value - 1; }
		return (($v = $qr_res->get('seq')) < $minimum_value) ? ($minimum_value - 1) : $v;
	}
	# -------------------------------------------------------
	/**
	 * Record new maximum sequence value for SERIAL element
	 *
	 * @param string $format Format to set sequence for
	 * @param string $element Element name to set sequence for
	 * @param string $idno_stub Identifier stub (identifier without serial value) to set sequence for
	 * @param string $value Maximum SERIAL value for this format/element/stub
	 * @return bool True on success, false on failure
	 */
	public function setSequenceMaxValue($format, $element, $idno_stub, $value) {
		$this->db->dieOnError(false);

		$this->db->query("
			DELETE FROM ca_multipart_idno_sequences
			WHERE format = ? AND element = ? AND idno_stub = ?
		", [$format, $element, $idno_stub]);

		$value = (int)preg_replace("![^\d]+!", "", $value);
		return $this->db->query("
			INSERT INTO ca_multipart_idno_sequences
			(format, element, idno_stub, seq)
			VALUES
			(?, ?, ?, ?)
		", [$format, $element, $idno_stub, $value]);
	}
	# -------------------------------------------------------
}
